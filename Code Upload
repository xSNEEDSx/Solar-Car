import tkinter as tk
from tkinter import simpledialog, messagebox
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import pickle


# Scrollable Frame for GUI
class ScrollableFrame(tk.Frame):
    def __init__(self, master, **kwargs):
        tk.Frame.__init__(self, master, **kwargs)

        self.canvas = tk.Canvas(self, borderwidth=0, background="#ffffff")
        self.canvas.grid(row=1, column=0, sticky="news")

        self.scrollbar = tk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.scrollbar.grid(row=1, column=1, sticky="news")

        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        self.canvas.bind('<Configure>', self.on_canvas_configure)

        self.frame = tk.Frame(self.canvas, background="#ffffff")
        self.canvas.create_window((5, 5), window=self.frame, anchor="nw")

    def on_canvas_configure(self, event):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))


# Function to save matrices to a file
def save_matrices_to_file(saved_matrices, filename="saved_matrices.pkl"):
    with open(filename, 'wb') as f:
        pickle.dump(saved_matrices, f)


# Function to load matrices from a file
def load_matrices_from_file(filename="saved_matrices.pkl"):
    try:
        with open(filename, 'rb') as f:
            return pickle.load(f)
    except (FileNotFoundError, EOFError):
        return {}  # Return empty dict if no file or file is empty


# GUI Class
class GUI:
    def __init__(self, master):
        self.master = master
        self.master.title("Phoenix Racing GUI")
        self.master.geometry('1600x1200')
        self.master.resizable(True, True)
        self.matrix_entries = []  # Store matrix entries

        self.scrollable_frame = ScrollableFrame(self.master)
        self.scrollable_frame.grid(row=8, column=0, rowspan=5, columnspan=3, padx=0, pady=0, sticky='news')
        self.scrollable_frame.canvas.config(width=1250, height=500)

        # Create a frame for each plot
        self.free_frame = tk.Frame(self.scrollable_frame.frame)
        self.free_frame.grid(row=1, column=0, padx=10, pady=10, sticky='news')

        self.rt60_low_plot_frame = tk.Frame(self.scrollable_frame.frame)
        self.rt60_low_plot_frame.grid(row=1, column=1, padx=10, pady=10, sticky='news')

        self.rt60_mid_plot_frame = tk.Frame(self.scrollable_frame.frame)
        self.rt60_mid_plot_frame.grid(row=2, column=0, padx=10, pady=10, sticky='news')

        self.rt60_high_plot_frame = tk.Frame(self.scrollable_frame.frame)
        self.rt60_high_plot_frame.grid(row=2, column=1, padx=10, pady=10, sticky='news')

        # Frequency change buttons
        self.low_freq_button = tk.Button(self.master, text="Saved Graphs", command=lambda: self.update_plots("low"))
        self.low_freq_button.grid(row=0, column=1, padx=(205, 1600), sticky='n')
        self.mid_freq_button = tk.Button(self.master, text="Mid Frequency", command=lambda: self.update_plots("mid"))
        self.mid_freq_button.grid(row=0, column=1, padx=(198, 1400), sticky='n')
        self.high_freq_button = tk.Button(self.master, text="High Frequency", command=lambda: self.update_plots("high"))
        self.high_freq_button.grid(row=0, column=1, padx=(202, 1200), sticky='n')

        # Create empty plots for RT60 values
        self.plot_empty(self.free_frame, title="Selected Graph")
        self.plot_empty(self.rt60_low_plot_frame, title="Second Graph")
        self.plot_empty(self.rt60_mid_plot_frame, title="Comparison Graph")
        self.plot_empty(self.rt60_high_plot_frame, title="Multi-Comparison Graph")

        # Load previously saved matrices from file
        self.saved_matrices = load_matrices_from_file()

        # Button to load file
        self.load_btn = tk.Button(self.master, text='Create Matrix', command=self.create_matrix_input_window)
        self.load_btn.grid(row=0, column=0, sticky='w', padx=5)

        # Display the name of the file selected
        self.load_field = tk.StringVar()
        self.load_field.set("Loaded File... ")
        self.load_field_frame = tk.Entry(self.master, width=60, textvariable=self.load_field)
        self.load_field_frame.grid(row=0, column=0, sticky='w', padx=100)

        # Display file conversion status
        self.load_conversion_to_wav = tk.StringVar()
        self.load_conversion_to_wav.set("WAV Conversion: No conversion necessary")
        self.load_conversion_to_wav_label = tk.Label(self.master, textvariable=self.load_conversion_to_wav)
        self.load_conversion_to_wav_label.grid(row=3, column=0, columnspan=1, sticky='w', padx=5)

        # Display channel conversion status
        self.load_conversion_to_mono = tk.StringVar()
        self.load_conversion_to_mono.set("Mono Conversion: No conversion necessary")
        self.load_conversion_to_mono_label = tk.Label(self.master, textvariable=self.load_conversion_to_mono)
        self.load_conversion_to_mono_label.grid(row=4, column=0, columnspan=1, sticky='w', padx=5)

        # Display initial file
        self.load_initial_file = tk.StringVar()
        self.load_initial_file.set("Initial File: None")
        self.load_initial_file_label = tk.Label(self.master, textvariable=self.load_initial_file)
        self.load_initial_file_label.grid(row=1, column=0, columnspan=1, sticky='w', padx=5)

        # Display initial channel count
        self.load_initial_channel = tk.StringVar()
        self.load_initial_channel.set("Initial Channel Count: None")
        self.load_initial_channel_label = tk.Label(self.master, textvariable=self.load_initial_channel)
        self.load_initial_channel_label.grid(row=2, column=0, columnspan=1, sticky='w', padx=5)

        # Display metadata (duration)
        self.load_duration = tk.StringVar()
        self.load_duration.set("Duration: None")
        self.load_duration_label = tk.Label(self.master, textvariable=self.load_duration)
        self.load_duration_label.grid(row=1, column=1, columnspan=1, sticky='w', padx=5)

        # Display metadata (artist)
        self.load_artist = tk.StringVar()
        self.load_artist.set("Artist: None")
        self.load_artist_label = tk.Label(self.master, textvariable=self.load_artist)
        self.load_artist_label.grid(row=2, column=1, columnspan=1, sticky='w', padx=5)

        # Display metadata (title)
        self.load_title = tk.StringVar()
        self.load_title.set("Title: None")
        self.load_title_label = tk.Label(self.master, textvariable=self.load_title)
        self.load_title_label.grid(row=3, column=1, columnspan=1, sticky='w', padx=5)

        # Display metadata (album)
        self.load_album = tk.StringVar()
        self.load_album.set("Album: None")
        self.load_album_label = tk.Label(self.master, textvariable=self.load_album)
        self.load_album_label.grid(row=4, column=1, columnspan=1, sticky='w', padx=5)

        # Display metadata (genre)
        self.load_genre = tk.StringVar()
        self.load_genre.set("Genre: None")
        self.load_genre_label = tk.Label(self.master, textvariable=self.load_genre)
        self.load_genre_label.grid(row=5, column=1, columnspan=1, sticky='w', padx=5)

        # Display metadata (date)
        self.load_year = tk.StringVar()
        self.load_year.set("Year: None")
        self.load_year_label = tk.Label(self.master, textvariable=self.load_year)
        self.load_year_label.grid(row=6, column=1, columnspan=1, sticky='w', padx=5)

        # Display frequency of highest resonance
        self.hz_highest = tk.StringVar()
        self.hz_highest.set("Frequency of Highest Resonance: None")
        self.hz_highest_label = tk.Label(self.master, textvariable=self.hz_highest)
        self.hz_highest_label.grid(row=5, column=0, columnspan=1, sticky='w', padx=5)

    def plot_empty(self, plot_frame, title=None):
        fig, ax = plt.subplots(figsize=(6, 4.2))
        if title:
            ax.set_title(title)
        ax.set_xlabel("X Label")
        ax.set_ylabel("Y Label")
        ax.grid()

        # Embed the plot in the plot_frame
        plot_canvas = FigureCanvasTkAgg(fig, master=plot_frame)
        plot_canvas.draw()
        plot_canvas.get_tk_widget().grid(row=0, column=0, sticky='news', padx=10, pady=10)

    def plot_matrix_in_selected_graph(self, time_values, voltage_values):
        # Clear the previous plot in the free_frame
        for widget in self.free_frame.winfo_children():
            widget.destroy()

        # Create a new plot for the matrix in the Selected Graph area
        fig, ax = plt.subplots(figsize=(6, 4.2))
        ax.plot(time_values, voltage_values, marker='o', linestyle='-', color='b')
        ax.set_title("Matrix Visualization (Voltage over Time)")
        ax.set_xlabel("Time (seconds)")
        ax.set_ylabel("Voltage (V)")
        ax.grid(True)

        # Embed the plot in the free_frame
        plot_canvas = FigureCanvasTkAgg(fig, master=self.free_frame)
        plot_canvas.draw()
        plot_canvas.get_tk_widget().grid(row=0, column=0, sticky='news', padx=10, pady=10)

    # Function to save created graphs
    saved_graphs = {}

    def save_function(self, saved_matrices, saved_graphs_dropdown, saved_graphs_var):
        # Ask user for a name for the matrix
        matrix_name = simpledialog.askstring("Input", "Enter a name for the matrix:")

        if not matrix_name:
            messagebox.showerror("Error", "Matrix name cannot be empty!")
            return

        if matrix_name in saved_matrices:
            messagebox.showerror("Error", f"A matrix named '{matrix_name}' already exists!")
            return

        # Collect the matrix data (time and voltage)
        try:
            voltage_values = []
            for entry in self.matrix_entries[0]:  # Assuming only one row for voltage entries
                value = float(entry.get())
                voltage_values.append(value)

            # Save the matrix as a dictionary with time and voltage data
            matrix_data = {
                'time': self.time_values,
                'voltage': voltage_values
            }

            # Store the matrix under the given name
            saved_matrices[matrix_name] = matrix_data

            # Add the matrix name to the dropdown (assuming 'saved_graphs_dropdown' is the dropdown menu)
            saved_graphs_dropdown['menu'].add_command(label=matrix_name,
                                                      command=tk._setit(saved_graphs_var, matrix_name))

            # Show success message
            messagebox.showinfo("Success", f"Matrix '{matrix_name}' saved successfully!")

        except ValueError:
            messagebox.showerror("Error", "Invalid voltage values entered!")
            return

    # Function to generate input fields for the matrix
    def create_matrix_input_window(self):
        window = tk.Toplevel(self.master)
        window.title("Matrix Input")

        # Determines input for columns
        second_sep_label = tk.Label(window, text="Enter the time separation in seconds:")
        second_sep_label.pack()
        second_sep_entry = tk.Entry(window)
        second_sep_entry.pack()

        total_time_label = tk.Label(window, text="Enter the total number of minutes:")
        total_time_label.pack()
        total_time_entry = tk.Entry(window)
        total_time_entry.pack()

        # Create a canvas for scrolling
        canvas = tk.Canvas(window, height=75)  # Set height for scrollable section
        scrollbar = tk.Scrollbar(window, orient="horizontal", command=canvas.xview)
        scrollable_frame = tk.Frame(canvas)

        # Configure the canvas
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"), width=500)  # Set the width of the canvas
        )

        # Create the scrollable area
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(xscrollcommand=scrollbar.set)

        # Pack the canvas and scrollbar
        canvas.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.BOTTOM, fill=tk.X)

        def generate_matrix_input():
            # Clear any previous matrix entries in scrollable_frame
            for widget in scrollable_frame.winfo_children():
                widget.destroy()

            try:
                # Retrieve the user inputs
                second_sep = float(second_sep_entry.get()) * 60  # Convert minutes to seconds
                max_time = float(total_time_entry.get()) * 60  # Max time remains in minutes
            except ValueError:
                messagebox.showerror("Input Error",
                                     "Please enter valid numbers for readings, minute separation, and total time.")
                return

            # Initialize current time for time labels
            current_time = 0
            col = 1  # Column 0 will have 'Time' label
            self.time_values = []  # Store time values here

            # Set 'Time' and 'Voltage' labels
            tk.Label(scrollable_frame, text="Time").grid(row=0, column=0, padx=5, pady=5)
            tk.Label(scrollable_frame, text="Voltage").grid(row=1, column=0, padx=5, pady=5)

            # Generate time labels dynamically based on minute separation and max time
            while current_time <= max_time:
                label = tk.Label(scrollable_frame, text=f"{current_time} s")
                label.grid(row=0, column=col, padx=5, pady=5)
                self.time_values.append(current_time)  # Save each time value
                current_time += second_sep / 60
                col += 1

            # Generate the matrix input fields for voltages
            self.matrix_entries = []  # Store the matrix entries for access
            row_entries = []
            for j in range(1, col):  # Entry fields for voltage values
                entry = tk.Entry(scrollable_frame, width=5)
                entry.grid(row=1, column=j, padx=5, pady=5)
                row_entries.append(entry)
            self.matrix_entries.append(row_entries)

        def print_matrix():
            try:
                # Print the matrix from the input fields
                matrix = []
                # We assume there are 2 rows: row 0 for "Time" and row 1 for "Voltage"
                for i in range(len(self.matrix_entries)):
                    row = []
                    for j in range(len(self.matrix_entries[i])):
                        # Collect matrix data from entry fields
                        row.append(int(self.matrix_entries[i][j].get()))  # Collect voltage values
                    matrix.append(row)

                result.delete('1.0', tk.END)  # Clear previous result
                for row in matrix:
                    result.insert(tk.END, ' '.join(map(str, row)) + '\n')  # Display matrix in a text widget or print
            except ValueError:
                messagebox.showerror("Input Error", "Please fill all entries with valid integers.")

        def graph_matrix():
            try:
                # Extract voltage values from matrix entries
                voltage_values = [float(entry.get()) for entry in self.matrix_entries[0]]

                # Plot the time vs voltage values in the "Selected Graph"
                self.plot_matrix_in_selected_graph(self.time_values, voltage_values)

            except ValueError:
                messagebox.showerror("Input Error", "Please ensure all voltage entries are filled with valid numbers.")

        generate_button = tk.Button(window, text="Generate Matrix", command=generate_matrix_input)
        generate_button.pack(pady=10)

        print_button = tk.Button(window, text="Print Matrix", command=print_matrix)
        print_button.pack(pady=10)

        result = tk.Text(window, height=10, width=30)
        result.pack(pady=10)

        graph_button = tk.Button(window, text="Graph Matrix", command=graph_matrix)
        graph_button.pack(side=tk.LEFT, padx=10)

        saved_matrices = {}
        save_button = tk.Button(window, text="Save Matrix", command=lambda: self.save_function(saved_matrices,
                                                                                               saved_graphs_dropdown,
                                                                                               saved_graphs_var))
        save_button.pack(side=tk.RIGHT, padx=20)

        saved_graphs_var = tk.StringVar(window)
        saved_graphs_var.set("Select a saved matrix")

        saved_graphs_dropdown = tk.OptionMenu(window, saved_graphs_var, "Select a saved matrix")
        saved_graphs_dropdown.pack()


def main():
    root = tk.Tk()
    app = GUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
